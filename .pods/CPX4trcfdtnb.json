{
  "id": "CPX4trcfdtnb",
  "parentId": "CPXjHc3JJxFK",
  "index": 1,
  "content": "\"function web_server()\\n    @info \\\"Listening on localhost:8082 ..\\\"\\n    # FIXME 8081 seems to be used by jupyterhub, I'm thus using 8082\\n    HTTP.serve(HTTP.Sockets.localhost, 8082) do request::HTTP.Request\\n        @show request\\n        @show request.method\\n\\n        payload = HTTP.payload(request)\\n        # CAUTION the String constructor method will clear the payload!\\n        # String(payload)\\n\\n        @info \\\"parsing payload ..\\\"\\n        jstr = String(payload)\\n        jobj = JSON.parse(jstr)\\n        xs, ys, as, ws, hs, Es, mask, diearea, params = decode_place_spec(jobj)\\n        @info \\\"running placement ..\\\"\\n\\n        # set seed. This should make the placement deterministic given the same\\n        # hyper-parameters\\n        Random.seed!(1234)\\n\\n        solxs, solys = place(xs, ys, ws, hs, Es, mask, diearea,\\n                             nsteps=params[\\\"place-nsteps\\\"],\\n                             nbins=params[\\\"place-nbins\\\"])\\n        solxs, solys, solas, conflicts = simulated_annealing_legalization(\\n            solxs, solys, as, ws, hs, mask, diearea,\\n            ncycles=params[\\\"sa-ncycles\\\"],\\n            nsteps=params[\\\"sa-nsteps\\\"],\\n            stepsize=params[\\\"sa-stepsize\\\"],\\n            theta_stepsize=params[\\\"sa-theta-stepsize\\\"])\\n\\n        # FIXME run iterations\\n\\n        # @info \\\"visualizing ..\\\"\\n        # R = Region(xs, ys, ws, hs, 300)\\n        # TODO for each incoming request, plot the process and save as log\\n        # visualize(xs, ys, ws, hs, R)\\n        # visualize(solxs, solys, ws, hs, R)\\n\\n        @info \\\"sending results back ..\\\"\\n        # I'll only send back cells, or cell locations\\n        # res_payload = encode(jobj, solxs, solys)\\n        #\\n        # the new payload just encode the xs and ys\\n        #\\n        # transform the result to corner based, because racket pict system convention\\n        #\\n        # UPDATE I'm using center at every locations, to be consistent for fixed locations\\n        # solxs = solxs .- ws ./ 2\\n        # solys = solys .- hs ./ 2\\n        res_payload = Dict(\\\"xs\\\"=>solxs, \\\"ys\\\"=>solys,\\n                           \\\"as\\\"=>solas,\\n                           # DEBUG\\n                           \\\"ws\\\"=>ws,\\n                           \\\"hs\\\"=>hs,\\n                           # should I add diearea here?\\n                           \\\"diearea\\\"=>diearea,\\n                           # for visualization and debug\\n                           \\\"conflicts\\\"=>conflicts) |> JSON.json\\n\\n        # TODO I also want to send back visualizations UPDATE probably just send\\n        # back the coordinates and optionally meta data during the process. The\\n        # rendering can be done on the client side.\\n\\n        # parse this directly as json, and save data to internal data structure\\n        # and start placement and routing.\\n        try\\n            # return HTTP.Response(\\\"Hello\\\")\\n            return HTTP.Response(res_payload)\\n        catch e\\n            return HTTP.Response(404, \\\"Error: $e\\\")\\n        end\\n    end\\nend\"",
  "column": 1,
  "fold": false,
  "thundar": false,
  "utility": false,
  "name": "",
  "lang": "julia",
  "type": "CODE",
  "imports": "{}",
  "exports": "{\"web_server\":false}",
  "midports": "{}",
  "repoId": "102c7cad-cc6a-4ac2-b30c-d5e168c069bf"
}