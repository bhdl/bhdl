{
  "id": "CPhM7hJBELTY",
  "parentId": "CPdEhDa4hc4h",
  "index": 27,
  "content": "\"function simulated_annealing_legalization(xs, ys, as, ws, hs, mask, diearea;\\n                                          vis=false, ncycles=20,\\n                                          nsteps=100, stepsize=50,\\n                                          theta_stepsize=0)\\n    # FIXME make a copy?\\n    xs = Float32.(xs)\\n    ys = Float32.(ys)\\n    ws = Float32.(ws)\\n    hs = Float32.(hs)\\n    as = Float32.(as)\\n    # FIXME this is for visulization and map back to valid region\\n    R = Region(xs, ys, ws, hs, diearea, 300)\\n    # actually I can probably parallelize the SA process, by trying to move\\n    # multiple components\\n    # t = 50\\n    # randomly choose a point\\n    @showprogress 0.1 \\\"Running for $ncycles cycles ..\\\" for cycle in 2:ncycles+1\\n        t = temperature(cycle)\\n        for step in 1:nsteps\\n            # no movable components, not meaningful, for debugging purpose\\n            if isempty(findall(mask .== 1)) break end\\n            i = rand(findall(mask .== 1))\\n            if cost_f(xs, ys, as, ws, hs,\\n                      xs[i], ys[i], as[i], ws[i], hs[i],\\n                      R, except=[i]) == 0\\n                continue\\n            end\\n            # i = rand(1:length(xs))\\n            # FIXME the scale of the movement\\n            x = xs[i] + stepsize * randn()\\n            y = ys[i] + stepsize * randn()\\n            # FIXME maybe have a separate variable to control change angle or not?\\n            # FIXME what should be the step size? was 50 for x,y\\n            #\\n            # if theta_stepsize, this is effectively not changing angle\\n            a = as[i] + theta_stepsize * randn()\\n\\n            # newxs = xs .+ randn()\\n            # newys = ys .+ randn()\\n            if accept(xs, ys, as, ws, hs,\\n                      x, y, a,\\n                      i, t, R)\\n                # @info \\\"cycle $cycle step $step accepted\\\"\\n                xs[i] = x\\n                ys[i] = y\\n                as[i] = a\\n            end\\n        end\\n\\n        # map back to valid region\\n        # validate_region!(xs, ys, ws, hs, R)\\n        let idx = (xs .- ws ./ 2 .< R.xmin) .& (mask .== 1)\\n            xs[idx] .= (ws ./ 2 .+ R.xmin)[idx]\\n        end\\n        let idx = (xs .+ ws ./ 2 .> R.xmax) .& (mask .== 1)\\n            xs[idx] .= (ws ./ 2 .- R.xmax)[idx]\\n        end\\n        let idx = (ys .- hs ./ 2 .< R.ymin) .& (mask .== 1)\\n            ys[idx] .= (hs ./ 2 .+ R.ymin)[idx]\\n        end\\n        let idx = (ys .+ hs ./ 2 .> R.ymax) .& (mask .== 1)\\n            ys[idx] .= (hs ./ 2 .- R.ymax)[idx]\\n        end\\n        \\n        # print how many conflicts\\n        conflicts = compute_conflicts(xs, ys, as, ws, hs, mask, R)\\n        @info \\\"cycle $cycle, remaining conflicts: $(length(conflicts))\\\"\\n\\n        # break if already no conflicts\\n        if length(conflicts) == 0 break end\\n        # FIXME visualize the angle\\n        if vis visualize(xs, ys, ws, hs, R) end\\n    end\\n    conflicts = compute_conflicts(xs, ys, as, ws, hs, mask, R)\\n    return xs, ys, as, conflicts\\nend\"",
  "column": 1,
  "fold": false,
  "thundar": false,
  "utility": false,
  "name": "",
  "lang": "julia",
  "type": "CODE",
  "imports": "{}",
  "exports": "{\"simulated_annealing_legalization\":false}",
  "midports": "{}",
  "repoId": "102c7cad-cc6a-4ac2-b30c-d5e168c069bf"
}