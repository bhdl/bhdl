#+TITLE: Implementation Notes

* TODO-list
** DONE visualize of placement result on racket side
CLOSED: [2020-04-18 Sat 18:30]
** STARTED write some boards

- arduino uno
- lichee nano
- gh60: https://github.com/komar007/gh60
- pyboard
- linux business card

*** other
- ergonomic (hebi) keyboard

** TODO detailed placement and legalization
** TODO fixed positions
** TODO Auto-Routing

** TODO Libraries
- https://github.com/Digi-Key/digikey-kicad-library

*** DONE schematic symbol library
CLOSED: [2020-02-20 四 14:27]
- kicad official library should be enough
*** TODO PCB footprint library

** Gerbers
*** gerber generation
**** design rules
*** IC->gerber add connections

Export a airwire connections onto the gerber file

* DONE-list

** DONE Julia and Racket interop
CLOSED: [2020-04-13 Mon 19:05]
*** build juila code into a static binary
Although the startup overhead will be reduced, I don't feel this is the best
option compared to client-server architecture.
*** DONE run Julia code as server
CLOSED: [2020-04-13 Mon 19:04]
What kind of server architecture? Raw socket? Or Http server?

- [[https://github.com/JuliaWeb/HTTP.jl][JuliaWeb/HTTP.jl]]: seems to be more mature, try this first.
- [[https://github.com/JuliaWeb/JuliaWebAPI.jl][JuliaWeb/JuliaWebAPI.jl]]: this is interesting, it wraps a julia function as a
  remote callable API.

And I should probably write local files and send filename via POST HTTP request
instead of sending all data via HTTP payload. The result should probably also be
a local filename.  *But* for a remote server, I still need to send the whole
file, so just do a whole file as payload.

In a word, use *HTTP.jl* to start a remote server that handles HTTP POST
request, and response the result file. Hopefully doing this async.

** lef/def and RePlAce
*** DONE connect lef with def
CLOSED: [2020-04-02 四 18:31]
*** DONE visualize lef/def
CLOSED: [2020-04-02 四 18:31]
*** CANCELED read academic benchmark ISPD05 and convert to lef/def
CLOSED: [2020-04-02 四 19:33]
*** DONE generate lef/def for my PCB
CLOSED: [2020-04-03 五 17:18]
*** DONE verify RePlAce performance on my PCB
CLOSED: [2020-04-03 五 18:15]

It crashed. How then? It is pretty much impossible to debug RePlAce code. Maybe
restart my own placement code?

*** DONE place.jl use lef/def and debug on my small scale
CLOSED: [2020-04-13 Mon 19:05]

** TODO use VLSI placement benchmarks
*** DONE figure out the format of ISPD benchmarks
CLOSED: [2020-03-16 一 21:05]
*** DONE run existing placers
CLOSED: [2020-03-16 一 21:05]
- [[https://github.com/limbo018/DREAMPlace][limbo018/DREAMPlace]]
- RePIAce code: [[https://github.com/The-OpenROAD-Project/RePlAce][The-OpenROAD-Project/RePlAce]]
- [[https://github.com/The-OpenROAD-Project/OpenROAD][The-OpenROAD-Project/OpenROAD]]: an umbrella project contains placers and
  routers as submodules

*** DONE read ISPD 05/06 benchmarks
CLOSED: [2020-03-16 一 22:03]
*** DONE visualization
CLOSED: [2020-03-17 二 00:39]

*** Implement other placers
- KraftWerk
- Capo
- mPL
- APlace
- FastPlace
- NTUplace3
- SimPL
- Eplace

** DONE constraint optimization
CLOSED: [2020-04-13 Mon 19:07]
*** whether this is mixed-size placement?
*** figure out PCB input format
*** generate a simple PCB input file
*** implement some placement algorithm
*** import back

** CANCELED Libraries
CLOSED: [2020-04-13 Mon 19:19]
- define all popular libraries
- compose them together
- write visualization and gerber generation for comp-IC
- assign footprint
